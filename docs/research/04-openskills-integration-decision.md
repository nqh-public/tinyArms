# OpenSkills-Inspired Skills Architecture

**Research Date**: 2025-10-30
**Status**: Researched - Ready for Implementation
**Phase**: 02 (Skills System Architecture)
**Implementation**: Phase 1 (Framework First)

**Sources**:
- OpenSkills spec: https://github.com/numman/openskills
- Plugin patterns: research/04-plugin-architecture-patterns.md
- User clarification: 4-round AskUserQuestion (2025-10-30)

---

## Problem

**Current**: Monolithic skill (code-linting only)
- Hardcoded CLI: cli.ts:22-83
- Embedded prompts: linter.ts:44-78
- No path to 2nd skill without duplication

**Decision**: Define architecture NOW before 2nd skill

---

## Solution

### Tooling: skill-creator

**Generate skills**: Use `.claude/skills/skill-creator/scripts/init_skill.py`
```bash
python3 .claude/skills/skill-creator/scripts/init_skill.py code-linting --path apps/tinyArms/skills
```

**Validate skills**: Use `quick_validate.py` before commits
```bash
python3 .claude/skills/skill-creator/scripts/quick_validate.py apps/tinyArms/skills/code-linting
```

### Structure (Per Skill)

```
skills/code-linting/
├── SKILL.md           # Generated by skill-creator (OpenSkills format)
├── config.yaml        # tinyArms runtime config (custom)
├── executor.ts        # Core logic (TypeScript, custom)
├── scripts/           # Optional: Executable helpers
├── references/        # Optional: Docs loaded to context
└── assets/            # Optional: Templates/configs
```

### SKILL.md (skill-creator Format)

**Requirements**:
- YAML frontmatter: `name:` (hyphen-case), `description:` (no `<>`)
- Structure pattern: Workflow-Based, Task-Based, Capabilities-Based, or Reference
- Must pass: `quick_validate.py`

**Example**:
```markdown
---
name: code-linting
description: Lint code against constitutional principles using Qwen2.5-Coder-3B. Use when checking Architecture-First, DRY, or Universal Reusability violations.
---

# Code Linting Skill

## Overview
Analyze code for constitutional violations NOT caught by pre-commit hooks.

## When to Use
- Pre-commit linting (fast)
- Weekly deep scans (slow)
- Manual code review

## Workflow

**Step 1**: Run linting
```bash
tinyarms lint <file> [--constitution <path>]
```

**Step 2**: Parse JSON output
```json
{
  "violations": [...],
  "summary": "...",
  "confidence": 0.85
}
```

## Success Criteria
- Exit code 0 if no violations
- Exit code 1 if violations found
```

### config.yaml (tinyArms-Specific)

**Purpose**: Runtime configuration (NO triggers section - extracted from SKILL.md frontmatter)

```yaml
# Model configuration (tiered routing per skill)
model:
  level: 2                          # Default tier (0-3)
  primary: qwen2.5-coder:3b-instruct
  fallback: qwen2.5-coder:7b
  confidence_threshold: 0.85

# Activation modes
activation:
  cli: true                         # Enable CLI invocation
  automated: true                   # Enable scheduled execution
  gui: false                        # GUI not built yet

# Automated scheduling (if activation.automated = true)
schedule:
  cron: "*/30 * * * *"              # Every 30 min
  watch_patterns: ["**/*.ts", "**/*.tsx"]
  batch_size: 10

# Performance constraints
performance:
  max_latency_ms: 3000
  memory_budget_mb: 2048
  battery_constraint: idle_only    # always | ac_only | idle_only

# Prompts (extracted from code)
prompts:
  system: "You are a linter...\n{constitution}"
  user: "Analyze:\n```\n{code}\n```"
```

**Note**: SKILL.md frontmatter (name + description) is source for routing triggers, not config.yaml

---

## Architecture (Three Components)

### 1. Skills Layer (Self-Contained)

**Per skill structure**:
```
skills/{name}/
├── SKILL.md           # OpenSkills format (agents read)
├── config.yaml        # Runtime config (no triggers)
├── index.ts           # Exports execute() + getConfig()
├── executor.ts        # Core logic (model loading, inference)
├── scripts/           # Optional: Helpers
├── references/        # Optional: Docs for context
└── assets/            # Optional: Templates
```

**index.ts interface** (flexible per skill):
```typescript
export async function execute(input: any): Promise<any>
export function getConfig(): SkillConfig
```

### 2. Routing Layer (Optional - Ambiguous Requests Only)

**src/routing/skill-registry.ts**:
- Auto-discovers skills in `skills/` folder
- Extracts SKILL.md frontmatter (name + description)
- Routes ambiguous requests via embeddings
- Direct lookups bypass routing

**When routing is used**:
- ❌ CLI: `tinyarms lint file.ts` → Direct (knows skill = code-linting)
- ❌ Scheduler: Reads config → Direct (knows which skill)
- ❌ GUI: User selects skill → Direct
- ✅ Ambiguous: "help me with this file" → Routing needed (semantic match)

### 3. Activation Layer

**src/activation/cli-handler.ts**:
- Maps CLI commands to skill names (lint → code-linting)
- No routing needed

**src/core/scheduler.ts**:
- Reads all config.yaml with `activation.automated = true`
- Schedules jobs (cron, file watchers)
- Direct execution per skill

**src/activation/gui-handler.ts** (future):
- SwiftUI menu bar app
- User selects skill from menu
- Direct execution

---

## Invocation Flows

### Direct Invocation (No Routing)

**CLI Mode**:
```
tinyarms lint file.ts
  ↓
cli-handler maps: "lint" → "code-linting"
  ↓
Load: skills/code-linting/index.ts
  ↓
Execute: skills/code-linting/executor.ts
  ↓
Return: JSON violations
```

**Scheduled Mode**:
```
scheduler reads config.yaml (activation.automated = true)
  ↓
cron triggers OR file watcher detects change
  ↓
Direct execution: skills/code-linting/index.ts
  ↓
Log to SQLite
```

**Claude Code Mode**:
```
Claude: openskills read tinyarms/code-linting
  ↓
Shows: SKILL.md instructions
  ↓
Claude runs: tinyarms lint file.ts
  ↓
Falls back to CLI mode (direct)
```

### Ambiguous Requests (Routing Needed)

```
User: "help me with this file"
  ↓
skill-registry.route("help me with this file")
  ↓
Extract all SKILL.md descriptions
  ↓
embeddinggemma: Semantic match
  ↓
Returns: Best matching skill name
  ↓
Load + execute skill
```

---

## Trade-Offs

### ✅ Benefits

- Modular architecture (easy to add skills 2-5)
- OpenSkills compatible (agents can invoke)
- Dual-mode support (CLI + autonomous)
- MCP-ready structure

### ❌ Costs

- Upfront work (framework before 2nd skill)
- 3 files per skill vs 1 monolithic
- Violates Principle XVII? (extract after 3+ duplicates)

**Justification**: Architecture decision, not code extraction. User decided on OpenSkills format.

---

## Implementation Plan

### Phase 1: First Skill (code-linting)

1. **Generate structure**: `init_skill.py code-linting`
2. **Edit SKILL.md**: Replace TODOs, choose Workflow-Based pattern
3. **Create config.yaml**: Model config, activation modes, schedule, performance, prompts
4. **Create index.ts**: Export `execute(input)` and `getConfig()`
5. **Create executor.ts**: Move linter.ts logic (no changes to logic)
6. **Add references/**: constitution-excerpt.md (2000 chars)
7. **Validate**: `quick_validate.py` passes

**Success**: `tinyarms lint file.ts` works identically + SKILL.md valid

**Key learnings**:
- SKILL.md frontmatter = routing triggers (no config.yaml duplication)
- Flexible input/output per skill (not standardized)
- config.yaml has activation modes (cli, automated, gui)

### Phase 2: Infrastructure

1. **Build skill-registry.ts** (src/routing/):
   - Auto-discover skills/ folder
   - Extract SKILL.md frontmatter (name + description)
   - Index for routing (optional, ambiguous requests only)

2. **Build cli-handler.ts** (src/activation/):
   - Map commands to skill names (lint → code-linting)
   - Direct skill loading (no routing)
   - Argument parsing

3. **Build routing for ambiguous** (src/routing/):
   - Hybrid: keywords → embeddings
   - embeddinggemma-300m for semantic matching

**Success**: CLI works with skill-registry, ambiguous requests route correctly

### Phase 3: Validate with 2nd Skill

1. Add file-naming OR markdown-analysis
2. Test skill-registry auto-discovery
3. Extract duplicated patterns (if 2+ exist)

**Success**: 2 skills working, infrastructure validated

### Phase 4: Autonomous Mode

1. **Build scheduler.ts** (src/core/):
   - Read all config.yaml with `activation.automated = true`
   - Schedule jobs (cron via node-cron or LaunchAgent)
   - File watchers (via chokidar)

2. **Add batching logic**: Process multiple files per execution
3. **Add semantic caching**: Level -1 cache (FrugalGPT pattern)
4. **LaunchAgent integration**: macOS native scheduling

**Success**: Skills run automatically on schedule, batched, cached

---

## Expected Impact

- **Modularity**: Clean plugin architecture for 5 skills
- **Agent integration**: Claude Code/Cursor/Aider can invoke
- **Maintainability**: Self-contained skills
- **Timeline**: 3-4 weeks (framework → validate → autonomous)

---

## References

- OpenSkills: https://github.com/numman/openskills
- Plugin patterns: research/04-plugin-architecture-patterns.md
- Current code: cli.ts:22-83, linter.ts:44-78

---

**Decision**: Adopt OpenSkills SKILL.md + tinyArms config.yaml architecture
**Status**: Ready for Phase 1 implementation
**Next**: Build framework before 2nd skill
